// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: RABackend.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum RABackend_Command: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// utility-based
  case nop // = 0

  /// no params
  case pause // = 1

  /// no params
  case report // = 2

  /// game-based
  case tick // = 10

  /// string param
  case connect // = 11

  /// no params
  case close // = 12

  /// no params
  case save // = 13

  /// interaction-based
  case beginOperation // = 20

  /// no params
  case cancelOperation // = 21

  /// facilityID, command
  case command // = 22

  /// character-based
  case face // = 60

  /// movement-based
  case addWaypoint // = 30

  /// characterID
  case abortMovement // = 32

  /// characterID
  case abortLastWaypoint // = 33

  /// item-character-based
  case consume // = 40

  /// itemParams
  case use // = 41

  /// itemParams
  case drop // = 42

  /// itemParams
  case pickup // = 43

  /// itemParams
  case equip // = 44

  /// itemParams
  case unequip // = 45

  /// what is this?
  case add // = 50

  /// testing only
  case increment // = 1000
  case decrement // = 1001
  case hasAdded // = 1002
  case hasRemoved // = 1003
  case UNRECOGNIZED(Int)

  public init() {
    self = .nop
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nop
    case 1: self = .pause
    case 2: self = .report
    case 10: self = .tick
    case 11: self = .connect
    case 12: self = .close
    case 13: self = .save
    case 20: self = .beginOperation
    case 21: self = .cancelOperation
    case 22: self = .command
    case 30: self = .addWaypoint
    case 32: self = .abortMovement
    case 33: self = .abortLastWaypoint
    case 40: self = .consume
    case 41: self = .use
    case 42: self = .drop
    case 43: self = .pickup
    case 44: self = .equip
    case 45: self = .unequip
    case 50: self = .add
    case 60: self = .face
    case 1000: self = .increment
    case 1001: self = .decrement
    case 1002: self = .hasAdded
    case 1003: self = .hasRemoved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .nop: return 0
    case .pause: return 1
    case .report: return 2
    case .tick: return 10
    case .connect: return 11
    case .close: return 12
    case .save: return 13
    case .beginOperation: return 20
    case .cancelOperation: return 21
    case .command: return 22
    case .addWaypoint: return 30
    case .abortMovement: return 32
    case .abortLastWaypoint: return 33
    case .consume: return 40
    case .use: return 41
    case .drop: return 42
    case .pickup: return 43
    case .equip: return 44
    case .unequip: return 45
    case .add: return 50
    case .face: return 60
    case .increment: return 1000
    case .decrement: return 1001
    case .hasAdded: return 1002
    case .hasRemoved: return 1003
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RABackend_Command: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [RABackend_Command] = [
    .nop,
    .pause,
    .report,
    .tick,
    .connect,
    .close,
    .save,
    .beginOperation,
    .cancelOperation,
    .command,
    .face,
    .addWaypoint,
    .abortMovement,
    .abortLastWaypoint,
    .consume,
    .use,
    .drop,
    .pickup,
    .equip,
    .unequip,
    .add,
    .increment,
    .decrement,
    .hasAdded,
    .hasRemoved,
  ]
}

#endif  // swift(>=4.2)

public enum RABackend_Orientation: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case point // = 0
  case flat // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .point
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .point
    case 1: self = .flat
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .point: return 0
    case .flat: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RABackend_Orientation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [RABackend_Orientation] = [
    .point,
    .flat,
  ]
}

#endif  // swift(>=4.2)

///enum CharacterClass {
///    player = 0;
///    character = 1;
///    npc = 2;
///}
///
///enum Attribute {
///    strength = 0;
///    constitution = 1;
///    dexterity = 2;
///    intelligence = 3;
///    wisdom = 4;
///    charisma = 5;
///    leadership = 6;
///    nobility = 7;
///    majesty = 8;
///}
public enum RABackend_Skill: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case speed // = 0
  case meditation // = 1
  case woodcutting // = 2
  case forestry // = 3
  case gathering // = 4
  case construction // = 5
  case farming // = 6
  case harvesting // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .speed
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .speed
    case 1: self = .meditation
    case 2: self = .woodcutting
    case 3: self = .forestry
    case 4: self = .gathering
    case 5: self = .construction
    case 6: self = .farming
    case 7: self = .harvesting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .speed: return 0
    case .meditation: return 1
    case .woodcutting: return 2
    case .forestry: return 3
    case .gathering: return 4
    case .construction: return 5
    case .farming: return 6
    case .harvesting: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RABackend_Skill: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [RABackend_Skill] = [
    .speed,
    .meditation,
    .woodcutting,
    .forestry,
    .gathering,
    .construction,
    .farming,
    .harvesting,
  ]
}

#endif  // swift(>=4.2)

public enum RABackend_EndorsementType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case plain // = 0
  case tallied // = 1
  case timed // = 2
  case skill // = 3
  case key // = 4
  case interaction // = 5
  case timeout // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .plain
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .plain
    case 1: self = .tallied
    case 2: self = .timed
    case 3: self = .skill
    case 4: self = .key
    case 5: self = .interaction
    case 6: self = .timeout
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .plain: return 0
    case .tallied: return 1
    case .timed: return 2
    case .skill: return 3
    case .key: return 4
    case .interaction: return 5
    case .timeout: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RABackend_EndorsementType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [RABackend_EndorsementType] = [
    .plain,
    .tallied,
    .timed,
    .skill,
    .key,
    .interaction,
    .timeout,
  ]
}

#endif  // swift(>=4.2)

public struct RABackend_PingReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tick: RABackend_Tick {
    get {return _tick ?? RABackend_Tick()}
    set {_tick = newValue}
  }
  /// Returns true if `tick` has been explicitly set.
  public var hasTick: Bool {return self._tick != nil}
  /// Clears the value of `tick`. Subsequent reads from it will return its default value.
  public mutating func clearTick() {self._tick = nil}

  public var scheduled: Dictionary<String,UInt64> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tick: RABackend_Tick? = nil
}

public struct RABackend_ServiceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var url: RABackend_Endpoint {
    get {return _url ?? RABackend_Endpoint()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _url: RABackend_Endpoint? = nil
}

public struct RABackend_Tick {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tick: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_Graphic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// figure this out
public struct RABackend_DiscoveryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// figure this out
public struct RABackend_DiscoveryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// figure this out
public struct RABackend_ActiveCharacterCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// figure this out
public struct RABackend_ActiveCharacterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// figure this out
public struct RABackend_VenueCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// figure this out
public struct RABackend_VenueResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_GameCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: RABackend_Command = .nop

  public var params: RABackend_GameCommand.OneOf_Params? = nil

  public var empty: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .empty(let v)? = params {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {params = .empty(newValue)}
  }

  public var stringParam: String {
    get {
      if case .stringParam(let v)? = params {return v}
      return String()
    }
    set {params = .stringParam(newValue)}
  }

  public var addWaypointParams: RABackend_AddWaypointParams {
    get {
      if case .addWaypointParams(let v)? = params {return v}
      return RABackend_AddWaypointParams()
    }
    set {params = .addWaypointParams(newValue)}
  }

  public var facing: UInt64 {
    get {
      if case .facing(let v)? = params {return v}
      return 0
    }
    set {params = .facing(newValue)}
  }

  public var itemID: RABackend_ItemID {
    get {
      if case .itemID(let v)? = params {return v}
      return RABackend_ItemID()
    }
    set {params = .itemID(newValue)}
  }

  public var droppedItemID: RABackend_DroppedItemID {
    get {
      if case .droppedItemID(let v)? = params {return v}
      return RABackend_DroppedItemID()
    }
    set {params = .droppedItemID(newValue)}
  }

  public var operation: RABackend_OperationSpecifier {
    get {
      if case .operation(let v)? = params {return v}
      return RABackend_OperationSpecifier()
    }
    set {params = .operation(newValue)}
  }

  public var interaction: RABackend_InteractionSpecifier {
    get {
      if case .interaction(let v)? = params {return v}
      return RABackend_InteractionSpecifier()
    }
    set {params = .interaction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Params: Equatable {
    case empty(SwiftProtobuf.Google_Protobuf_Empty)
    case stringParam(String)
    case addWaypointParams(RABackend_AddWaypointParams)
    case facing(UInt64)
    case itemID(RABackend_ItemID)
    case droppedItemID(RABackend_DroppedItemID)
    case operation(RABackend_OperationSpecifier)
    case interaction(RABackend_InteractionSpecifier)

  #if !swift(>=4.1)
    public static func ==(lhs: RABackend_GameCommand.OneOf_Params, rhs: RABackend_GameCommand.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringParam, .stringParam): return {
        guard case .stringParam(let l) = lhs, case .stringParam(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addWaypointParams, .addWaypointParams): return {
        guard case .addWaypointParams(let l) = lhs, case .addWaypointParams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.facing, .facing): return {
        guard case .facing(let l) = lhs, case .facing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.itemID, .itemID): return {
        guard case .itemID(let l) = lhs, case .itemID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.droppedItemID, .droppedItemID): return {
        guard case .droppedItemID(let l) = lhs, case .droppedItemID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operation, .operation): return {
        guard case .operation(let l) = lhs, case .operation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.interaction, .interaction): return {
        guard case .interaction(let l) = lhs, case .interaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct RABackend_VenuePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hexX: Int64 = 0

  public var hexY: Int64 = 0

  public var x: Int64 = 0

  public var y: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_Locality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var position: RABackend_VenuePosition {
    get {return _position ?? RABackend_VenuePosition()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var waypoints: [RABackend_Waypoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: RABackend_VenuePosition? = nil
}

public struct RABackend_Waypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var destination: RABackend_VenuePosition {
    get {return _destination ?? RABackend_VenuePosition()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  public var start: UInt64 = 0

  public var travelTime: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _destination: RABackend_VenuePosition? = nil
}

public struct RABackend_Item {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemID: RABackend_ItemID {
    get {return _itemID ?? RABackend_ItemID()}
    set {_itemID = newValue}
  }
  /// Returns true if `itemID` has been explicitly set.
  public var hasItemID: Bool {return self._itemID != nil}
  /// Clears the value of `itemID`. Subsequent reads from it will return its default value.
  public mutating func clearItemID() {self._itemID = nil}

  public var typeID: RABackend_ItemTypeID {
    get {return _typeID ?? RABackend_ItemTypeID()}
    set {_typeID = newValue}
  }
  /// Returns true if `typeID` has been explicitly set.
  public var hasTypeID: Bool {return self._typeID != nil}
  /// Clears the value of `typeID`. Subsequent reads from it will return its default value.
  public mutating func clearTypeID() {self._typeID = nil}

  public var quantity: UInt64 = 0

  public var isEquipped: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _itemID: RABackend_ItemID? = nil
  fileprivate var _typeID: RABackend_ItemTypeID? = nil
}

public struct RABackend_ItemSpecifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemType: String = String()

  public var quantity: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_DroppedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var droppedItemID: RABackend_DroppedItemID {
    get {return _droppedItemID ?? RABackend_DroppedItemID()}
    set {_droppedItemID = newValue}
  }
  /// Returns true if `droppedItemID` has been explicitly set.
  public var hasDroppedItemID: Bool {return self._droppedItemID != nil}
  /// Clears the value of `droppedItemID`. Subsequent reads from it will return its default value.
  public mutating func clearDroppedItemID() {self._droppedItemID = nil}

  public var item: RABackend_Item {
    get {return _item ?? RABackend_Item()}
    set {_item = newValue}
  }
  /// Returns true if `item` has been explicitly set.
  public var hasItem: Bool {return self._item != nil}
  /// Clears the value of `item`. Subsequent reads from it will return its default value.
  public mutating func clearItem() {self._item = nil}

  public var position: RABackend_VenuePosition {
    get {return _position ?? RABackend_VenuePosition()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _droppedItemID: RABackend_DroppedItemID? = nil
  fileprivate var _item: RABackend_Item? = nil
  fileprivate var _position: RABackend_VenuePosition? = nil
}

public struct RABackend_MountingPoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var characterID: RABackend_CharacterID {
    get {return _characterID ?? RABackend_CharacterID()}
    set {_characterID = newValue}
  }
  /// Returns true if `characterID` has been explicitly set.
  public var hasCharacterID: Bool {return self._characterID != nil}
  /// Clears the value of `characterID`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterID() {self._characterID = nil}

  public var mountingPoints: Dictionary<String,String> = [:]

  public var capacities: Dictionary<String,UInt64> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _characterID: RABackend_CharacterID? = nil
}

public struct RABackend_AddWaypointParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var position: RABackend_VenuePosition {
    get {return _position ?? RABackend_VenuePosition()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var at: UInt64 = 0

  public var `for`: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _position: RABackend_VenuePosition? = nil
}

public struct RABackend_GameStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tick: UInt64 {
    get {return _storage._tick}
    set {_uniqueStorage()._tick = newValue}
  }

  public var Venue: RABackend_Venue {
    get {return _storage._Venue ?? RABackend_Venue()}
    set {_uniqueStorage()._Venue = newValue}
  }
  /// Returns true if `Venue` has been explicitly set.
  public var hasVenue: Bool {return _storage._Venue != nil}
  /// Clears the value of `Venue`. Subsequent reads from it will return its default value.
  public mutating func clearVenue() {_uniqueStorage()._Venue = nil}

  public var activeCharacter: RABackend_ActiveCharacter {
    get {return _storage._activeCharacter ?? RABackend_ActiveCharacter()}
    set {_uniqueStorage()._activeCharacter = newValue}
  }
  /// Returns true if `activeCharacter` has been explicitly set.
  public var hasActiveCharacter: Bool {return _storage._activeCharacter != nil}
  /// Clears the value of `activeCharacter`. Subsequent reads from it will return its default value.
  public mutating func clearActiveCharacter() {_uniqueStorage()._activeCharacter = nil}

  public var hasCharactersPresentList_p: Bool {
    get {return _storage._hasCharactersPresentList_p}
    set {_uniqueStorage()._hasCharactersPresentList_p = newValue}
  }

  public var charactersPresentList: [RABackend_Character] {
    get {return _storage._charactersPresentList}
    set {_uniqueStorage()._charactersPresentList = newValue}
  }

  public var hasFacilityList_p: Bool {
    get {return _storage._hasFacilityList_p}
    set {_uniqueStorage()._hasFacilityList_p = newValue}
  }

  public var facilities: [RABackend_Facility] {
    get {return _storage._facilities}
    set {_uniqueStorage()._facilities = newValue}
  }

  public var hasDroppedItemsList_p: Bool {
    get {return _storage._hasDroppedItemsList_p}
    set {_uniqueStorage()._hasDroppedItemsList_p = newValue}
  }

  public var droppedItems: [RABackend_DroppedItem] {
    get {return _storage._droppedItems}
    set {_uniqueStorage()._droppedItems = newValue}
  }

  public var hasOperation_p: Bool {
    get {return _storage._hasOperation_p}
    set {_uniqueStorage()._hasOperation_p = newValue}
  }

  public var timeRemaining: UInt64 {
    get {return _storage._timeRemaining}
    set {_uniqueStorage()._timeRemaining = newValue}
  }

  public var result: RABackend_OperationResult {
    get {return _storage._result ?? RABackend_OperationResult()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {_uniqueStorage()._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct RABackend_OperationSpecifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var facility: RABackend_FacilityID {
    get {return _facility ?? RABackend_FacilityID()}
    set {_facility = newValue}
  }
  /// Returns true if `facility` has been explicitly set.
  public var hasFacility: Bool {return self._facility != nil}
  /// Clears the value of `facility`. Subsequent reads from it will return its default value.
  public mutating func clearFacility() {self._facility = nil}

  public var operation: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _facility: RABackend_FacilityID? = nil
}

public struct RABackend_InteractionSpecifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var facility: RABackend_FacilityID {
    get {return _facility ?? RABackend_FacilityID()}
    set {_facility = newValue}
  }
  /// Returns true if `facility` has been explicitly set.
  public var hasFacility: Bool {return self._facility != nil}
  /// Clears the value of `facility`. Subsequent reads from it will return its default value.
  public mutating func clearFacility() {self._facility = nil}

  public var operation: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _facility: RABackend_FacilityID? = nil
}

public struct RABackend_OperationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeRemaining: UInt64 = 0

  public var isAnticipatory: Bool = false

  public var willContinue: Bool = false

  public var awardedItems: [RABackend_Item] = []

  public var awardedXp: [RABackend_XP] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_XP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var skill: String = String()

  public var xp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_OperationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newItems: [RABackend_Item] = []

  public var consumedItems: [RABackend_ItemSpecifier] = []

  public var skill: RABackend_Skill = .speed

  public var xpEarned: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This data rarely changes so it makes sense to keep it discrete.
public struct RABackend_Venue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: RABackend_VenueID {
    get {return _id ?? RABackend_VenueID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var name: String = String()

  public var description_p: String = String()

  public var region: Data = Data()

  public var orientation: RABackend_Orientation = .point

  public var bounds: RABackend_Size {
    get {return _bounds ?? RABackend_Size()}
    set {_bounds = newValue}
  }
  /// Returns true if `bounds` has been explicitly set.
  public var hasBounds: Bool {return self._bounds != nil}
  /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
  public mutating func clearBounds() {self._bounds = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: RABackend_VenueID? = nil
  fileprivate var _bounds: RABackend_Size? = nil
}

public struct RABackend_DroppedItemList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_Facility {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: RABackend_FacilityID {
    get {return _id ?? RABackend_FacilityID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var kind: String = String()

  public var position: RABackend_VenuePosition {
    get {return _position ?? RABackend_VenuePosition()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {self._position = nil}

  public var interactions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: RABackend_FacilityID? = nil
  fileprivate var _position: RABackend_VenuePosition? = nil
}

public struct RABackend_FacilityList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var facilities: [RABackend_Facility] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_Region {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var region: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_Size {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Double = 0

  public var height: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_Endorsement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: RABackend_EndorsementType = .plain

  public var buff: String {
    get {return _buff ?? String()}
    set {_buff = newValue}
  }
  /// Returns true if `buff` has been explicitly set.
  public var hasBuff: Bool {return self._buff != nil}
  /// Clears the value of `buff`. Subsequent reads from it will return its default value.
  public mutating func clearBuff() {self._buff = nil}

  public var params: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _buff: String? = nil
}

public struct RABackend_Character {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var characterID: RABackend_CharacterID {
    get {return _characterID ?? RABackend_CharacterID()}
    set {_characterID = newValue}
  }
  /// Returns true if `characterID` has been explicitly set.
  public var hasCharacterID: Bool {return self._characterID != nil}
  /// Clears the value of `characterID`. Subsequent reads from it will return its default value.
  public mutating func clearCharacterID() {self._characterID = nil}

  public var displayName: String = String()

  ///    CharacterClass type = 3;
  public var venue: RABackend_VenueID {
    get {return _venue ?? RABackend_VenueID()}
    set {_venue = newValue}
  }
  /// Returns true if `venue` has been explicitly set.
  public var hasVenue: Bool {return self._venue != nil}
  /// Clears the value of `venue`. Subsequent reads from it will return its default value.
  public mutating func clearVenue() {self._venue = nil}

  public var locality: RABackend_Locality {
    get {return _locality ?? RABackend_Locality()}
    set {_locality = newValue}
  }
  /// Returns true if `locality` has been explicitly set.
  public var hasLocality: Bool {return self._locality != nil}
  /// Clears the value of `locality`. Subsequent reads from it will return its default value.
  public mutating func clearLocality() {self._locality = nil}

  public var facing: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _characterID: RABackend_CharacterID? = nil
  fileprivate var _venue: RABackend_VenueID? = nil
  fileprivate var _locality: RABackend_Locality? = nil
}

public struct RABackend_ActiveCharacter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    bytes data = 2;
  public var id: RABackend_CharacterID {
    get {return _storage._id ?? RABackend_CharacterID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var Character: RABackend_Character {
    get {return _storage._Character ?? RABackend_Character()}
    set {_uniqueStorage()._Character = newValue}
  }
  /// Returns true if `Character` has been explicitly set.
  public var hasCharacter: Bool {return _storage._Character != nil}
  /// Clears the value of `Character`. Subsequent reads from it will return its default value.
  public mutating func clearCharacter() {_uniqueStorage()._Character = nil}

  public var attributes: Dictionary<String,Int64> {
    get {return _storage._attributes}
    set {_uniqueStorage()._attributes = newValue}
  }

  public var items: [RABackend_Item] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  public var mountingPoints: RABackend_MountingPoints {
    get {return _storage._mountingPoints ?? RABackend_MountingPoints()}
    set {_uniqueStorage()._mountingPoints = newValue}
  }
  /// Returns true if `mountingPoints` has been explicitly set.
  public var hasMountingPoints: Bool {return _storage._mountingPoints != nil}
  /// Clears the value of `mountingPoints`. Subsequent reads from it will return its default value.
  public mutating func clearMountingPoints() {_uniqueStorage()._mountingPoints = nil}

  public var memes: Data {
    get {return _storage._memes}
    set {_uniqueStorage()._memes = newValue}
  }

  public var buffs: Data {
    get {return _storage._buffs}
    set {_uniqueStorage()._buffs = newValue}
  }

  public var attributeTimesRemaining: Dictionary<String,UInt64> {
    get {return _storage._attributeTimesRemaining}
    set {_uniqueStorage()._attributeTimesRemaining = newValue}
  }

  public var skillTimesRemaining: Dictionary<String,UInt64> {
    get {return _storage._skillTimesRemaining}
    set {_uniqueStorage()._skillTimesRemaining = newValue}
  }

  public var endorsements: Dictionary<String,RABackend_Endorsement> {
    get {return _storage._endorsements}
    set {_uniqueStorage()._endorsements = newValue}
  }

  public var operation: RABackend_OperationStatus {
    get {return _storage._operation ?? RABackend_OperationStatus()}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  public var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  public mutating func clearOperation() {_uniqueStorage()._operation = nil}

  public var occupied: Bool {
    get {return _storage._occupied}
    set {_uniqueStorage()._occupied = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct RABackend_Credentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var player: RABackend_PlayerID {
    get {return _player ?? RABackend_PlayerID()}
    set {_player = newValue}
  }
  /// Returns true if `player` has been explicitly set.
  public var hasPlayer: Bool {return self._player != nil}
  /// Clears the value of `player`. Subsequent reads from it will return its default value.
  public mutating func clearPlayer() {self._player = nil}

  public var passkey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _player: RABackend_PlayerID? = nil
}

public struct RABackend_AuthenticationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authenticated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_NewPlayerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var familyName: String = String()

  public var playerID: RABackend_PlayerID {
    get {return _playerID ?? RABackend_PlayerID()}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  public var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  public mutating func clearPlayerID() {self._playerID = nil}

  public var passwordHash: String = String()

  public var salt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _playerID: RABackend_PlayerID? = nil
}

public struct RABackend_NewPlayerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: RABackend_NewPlayerResponse.OneOf_Response? = nil

  public var playerID: RABackend_PlayerID {
    get {
      if case .playerID(let v)? = response {return v}
      return RABackend_PlayerID()
    }
    set {response = .playerID(newValue)}
  }

  public var empty: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .empty(let v)? = response {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {response = .empty(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case playerID(RABackend_PlayerID)
    case empty(SwiftProtobuf.Google_Protobuf_Empty)

  #if !swift(>=4.1)
    public static func ==(lhs: RABackend_NewPlayerResponse.OneOf_Response, rhs: RABackend_NewPlayerResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.playerID, .playerID): return {
        guard case .playerID(let l) = lhs, case .playerID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct RABackend_SaltResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var salt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_LoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var playerID: RABackend_PlayerID {
    get {return _playerID ?? RABackend_PlayerID()}
    set {_playerID = newValue}
  }
  /// Returns true if `playerID` has been explicitly set.
  public var hasPlayerID: Bool {return self._playerID != nil}
  /// Clears the value of `playerID`. Subsequent reads from it will return its default value.
  public mutating func clearPlayerID() {self._playerID = nil}

  public var hash: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _playerID: RABackend_PlayerID? = nil
}

public struct RABackend_LoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responses: RABackend_LoginResponse.OneOf_Responses? = nil

  public var empty: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .empty(let v)? = responses {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {responses = .empty(newValue)}
  }

  public var info: RABackend_LoginInfo {
    get {
      if case .info(let v)? = responses {return v}
      return RABackend_LoginInfo()
    }
    set {responses = .info(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Responses: Equatable {
    case empty(SwiftProtobuf.Google_Protobuf_Empty)
    case info(RABackend_LoginInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: RABackend_LoginResponse.OneOf_Responses, rhs: RABackend_LoginResponse.OneOf_Responses) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.empty, .empty): return {
        guard case .empty(let l) = lhs, case .empty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.info, .info): return {
        guard case .info(let l) = lhs, case .info(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct RABackend_LoginInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeCharacter: RABackend_CharacterID {
    get {return _activeCharacter ?? RABackend_CharacterID()}
    set {_activeCharacter = newValue}
  }
  /// Returns true if `activeCharacter` has been explicitly set.
  public var hasActiveCharacter: Bool {return self._activeCharacter != nil}
  /// Clears the value of `activeCharacter`. Subsequent reads from it will return its default value.
  public mutating func clearActiveCharacter() {self._activeCharacter = nil}

  public var passkey: String = String()

  public var id: RABackend_PlayerID {
    get {return _id ?? RABackend_PlayerID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var gameplayPortalEndpoint: RABackend_Endpoint {
    get {return _gameplayPortalEndpoint ?? RABackend_Endpoint()}
    set {_gameplayPortalEndpoint = newValue}
  }
  /// Returns true if `gameplayPortalEndpoint` has been explicitly set.
  public var hasGameplayPortalEndpoint: Bool {return self._gameplayPortalEndpoint != nil}
  /// Clears the value of `gameplayPortalEndpoint`. Subsequent reads from it will return its default value.
  public mutating func clearGameplayPortalEndpoint() {self._gameplayPortalEndpoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _activeCharacter: RABackend_CharacterID? = nil
  fileprivate var _id: RABackend_PlayerID? = nil
  fileprivate var _gameplayPortalEndpoint: RABackend_Endpoint? = nil
}

public struct RABackend_VenueID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_PlayerID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_ItemTypeID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_ItemID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_DroppedItemID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_FacilityID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_CharacterID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RABackend_CharacterIDList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeCharacter: RABackend_CharacterID {
    get {return _activeCharacter ?? RABackend_CharacterID()}
    set {_activeCharacter = newValue}
  }
  /// Returns true if `activeCharacter` has been explicitly set.
  public var hasActiveCharacter: Bool {return self._activeCharacter != nil}
  /// Clears the value of `activeCharacter`. Subsequent reads from it will return its default value.
  public mutating func clearActiveCharacter() {self._activeCharacter = nil}

  public var characters: [RABackend_CharacterID] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _activeCharacter: RABackend_CharacterID? = nil
}

public struct RABackend_Endpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var port: String = String()

  public var test: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension RABackend_Command: @unchecked Sendable {}
extension RABackend_Orientation: @unchecked Sendable {}
extension RABackend_Skill: @unchecked Sendable {}
extension RABackend_EndorsementType: @unchecked Sendable {}
extension RABackend_PingReport: @unchecked Sendable {}
extension RABackend_ServiceList: @unchecked Sendable {}
extension RABackend_Tick: @unchecked Sendable {}
extension RABackend_Graphic: @unchecked Sendable {}
extension RABackend_DiscoveryRequest: @unchecked Sendable {}
extension RABackend_DiscoveryResponse: @unchecked Sendable {}
extension RABackend_ActiveCharacterCommand: @unchecked Sendable {}
extension RABackend_ActiveCharacterResponse: @unchecked Sendable {}
extension RABackend_VenueCommand: @unchecked Sendable {}
extension RABackend_VenueResponse: @unchecked Sendable {}
extension RABackend_GameCommand: @unchecked Sendable {}
extension RABackend_GameCommand.OneOf_Params: @unchecked Sendable {}
extension RABackend_VenuePosition: @unchecked Sendable {}
extension RABackend_Locality: @unchecked Sendable {}
extension RABackend_Waypoint: @unchecked Sendable {}
extension RABackend_Item: @unchecked Sendable {}
extension RABackend_ItemSpecifier: @unchecked Sendable {}
extension RABackend_DroppedItem: @unchecked Sendable {}
extension RABackend_MountingPoints: @unchecked Sendable {}
extension RABackend_AddWaypointParams: @unchecked Sendable {}
extension RABackend_GameStatus: @unchecked Sendable {}
extension RABackend_OperationSpecifier: @unchecked Sendable {}
extension RABackend_InteractionSpecifier: @unchecked Sendable {}
extension RABackend_OperationStatus: @unchecked Sendable {}
extension RABackend_XP: @unchecked Sendable {}
extension RABackend_OperationResult: @unchecked Sendable {}
extension RABackend_Venue: @unchecked Sendable {}
extension RABackend_DroppedItemList: @unchecked Sendable {}
extension RABackend_Facility: @unchecked Sendable {}
extension RABackend_FacilityList: @unchecked Sendable {}
extension RABackend_Region: @unchecked Sendable {}
extension RABackend_Size: @unchecked Sendable {}
extension RABackend_Endorsement: @unchecked Sendable {}
extension RABackend_Character: @unchecked Sendable {}
extension RABackend_ActiveCharacter: @unchecked Sendable {}
extension RABackend_Credentials: @unchecked Sendable {}
extension RABackend_AuthenticationResponse: @unchecked Sendable {}
extension RABackend_NewPlayerRequest: @unchecked Sendable {}
extension RABackend_NewPlayerResponse: @unchecked Sendable {}
extension RABackend_NewPlayerResponse.OneOf_Response: @unchecked Sendable {}
extension RABackend_SaltResponse: @unchecked Sendable {}
extension RABackend_LoginRequest: @unchecked Sendable {}
extension RABackend_LoginResponse: @unchecked Sendable {}
extension RABackend_LoginResponse.OneOf_Responses: @unchecked Sendable {}
extension RABackend_LoginInfo: @unchecked Sendable {}
extension RABackend_VenueID: @unchecked Sendable {}
extension RABackend_PlayerID: @unchecked Sendable {}
extension RABackend_ItemTypeID: @unchecked Sendable {}
extension RABackend_ItemID: @unchecked Sendable {}
extension RABackend_DroppedItemID: @unchecked Sendable {}
extension RABackend_FacilityID: @unchecked Sendable {}
extension RABackend_CharacterID: @unchecked Sendable {}
extension RABackend_CharacterIDList: @unchecked Sendable {}
extension RABackend_Endpoint: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "RABackend"

extension RABackend_Command: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "nop"),
    1: .same(proto: "pause"),
    2: .same(proto: "report"),
    10: .same(proto: "tick"),
    11: .same(proto: "connect"),
    12: .same(proto: "close"),
    13: .same(proto: "save"),
    20: .same(proto: "beginOperation"),
    21: .same(proto: "cancelOperation"),
    22: .same(proto: "command"),
    30: .same(proto: "addWaypoint"),
    32: .same(proto: "abortMovement"),
    33: .same(proto: "abortLastWaypoint"),
    40: .same(proto: "consume"),
    41: .same(proto: "use"),
    42: .same(proto: "drop"),
    43: .same(proto: "pickup"),
    44: .same(proto: "equip"),
    45: .same(proto: "unequip"),
    50: .same(proto: "add"),
    60: .same(proto: "face"),
    1000: .same(proto: "increment"),
    1001: .same(proto: "decrement"),
    1002: .same(proto: "hasAdded"),
    1003: .same(proto: "hasRemoved"),
  ]
}

extension RABackend_Orientation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "point"),
    1: .same(proto: "flat"),
  ]
}

extension RABackend_Skill: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "speed"),
    1: .same(proto: "meditation"),
    2: .same(proto: "woodcutting"),
    3: .same(proto: "forestry"),
    4: .same(proto: "gathering"),
    5: .same(proto: "construction"),
    6: .same(proto: "farming"),
    7: .same(proto: "harvesting"),
  ]
}

extension RABackend_EndorsementType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "plain"),
    1: .same(proto: "tallied"),
    2: .same(proto: "timed"),
    3: .same(proto: "skill"),
    4: .same(proto: "key"),
    5: .same(proto: "interaction"),
    6: .same(proto: "timeout"),
  ]
}

extension RABackend_PingReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PingReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tick"),
    2: .same(proto: "scheduled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tick) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.scheduled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tick {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.scheduled.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.scheduled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_PingReport, rhs: RABackend_PingReport) -> Bool {
    if lhs._tick != rhs._tick {return false}
    if lhs.scheduled != rhs.scheduled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_ServiceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_ServiceList, rhs: RABackend_ServiceList) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Tick: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tick"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tick"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tick) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tick != 0 {
      try visitor.visitSingularUInt64Field(value: self.tick, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Tick, rhs: RABackend_Tick) -> Bool {
    if lhs.tick != rhs.tick {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Graphic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Graphic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Graphic, rhs: RABackend_Graphic) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_DiscoveryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoveryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_DiscoveryRequest, rhs: RABackend_DiscoveryRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_DiscoveryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoveryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_DiscoveryResponse, rhs: RABackend_DiscoveryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_ActiveCharacterCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveCharacterCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_ActiveCharacterCommand, rhs: RABackend_ActiveCharacterCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_ActiveCharacterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveCharacterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_ActiveCharacterResponse, rhs: RABackend_ActiveCharacterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_VenueCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VenueCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_VenueCommand, rhs: RABackend_VenueCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_VenueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VenueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_VenueResponse, rhs: RABackend_VenueResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_GameCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "empty"),
    3: .same(proto: "stringParam"),
    5: .same(proto: "addWaypointParams"),
    6: .same(proto: "facing"),
    7: .same(proto: "itemID"),
    8: .same(proto: "droppedItemID"),
    9: .same(proto: "operation"),
    11: .same(proto: "interaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .empty(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.params != nil {try decoder.handleConflictingOneOf()}
          self.params = .stringParam(v)
        }
      }()
      case 5: try {
        var v: RABackend_AddWaypointParams?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .addWaypointParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .addWaypointParams(v)
        }
      }()
      case 6: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.params != nil {try decoder.handleConflictingOneOf()}
          self.params = .facing(v)
        }
      }()
      case 7: try {
        var v: RABackend_ItemID?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .itemID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .itemID(v)
        }
      }()
      case 8: try {
        var v: RABackend_DroppedItemID?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .droppedItemID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .droppedItemID(v)
        }
      }()
      case 9: try {
        var v: RABackend_OperationSpecifier?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .operation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .operation(v)
        }
      }()
      case 11: try {
        var v: RABackend_InteractionSpecifier?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .interaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .interaction(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != .nop {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    switch self.params {
    case .empty?: try {
      guard case .empty(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stringParam?: try {
      guard case .stringParam(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .addWaypointParams?: try {
      guard case .addWaypointParams(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .facing?: try {
      guard case .facing(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }()
    case .itemID?: try {
      guard case .itemID(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .droppedItemID?: try {
      guard case .droppedItemID(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .operation?: try {
      guard case .operation(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .interaction?: try {
      guard case .interaction(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_GameCommand, rhs: RABackend_GameCommand) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_VenuePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VenuePosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hexX"),
    2: .same(proto: "hexY"),
    3: .same(proto: "x"),
    4: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.hexX) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.hexY) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.x) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hexX != 0 {
      try visitor.visitSingularInt64Field(value: self.hexX, fieldNumber: 1)
    }
    if self.hexY != 0 {
      try visitor.visitSingularInt64Field(value: self.hexY, fieldNumber: 2)
    }
    if self.x != 0 {
      try visitor.visitSingularInt64Field(value: self.x, fieldNumber: 3)
    }
    if self.y != 0 {
      try visitor.visitSingularInt64Field(value: self.y, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_VenuePosition, rhs: RABackend_VenuePosition) -> Bool {
    if lhs.hexX != rhs.hexX {return false}
    if lhs.hexY != rhs.hexY {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Locality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Locality"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "waypoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.waypoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.waypoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.waypoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Locality, rhs: RABackend_Locality) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs.waypoints != rhs.waypoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Waypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Waypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "start"),
    3: .same(proto: "travelTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.start) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.travelTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.start != 0 {
      try visitor.visitSingularUInt64Field(value: self.start, fieldNumber: 2)
    }
    if self.travelTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.travelTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Waypoint, rhs: RABackend_Waypoint) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs.start != rhs.start {return false}
    if lhs.travelTime != rhs.travelTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemID"),
    2: .same(proto: "typeID"),
    3: .same(proto: "quantity"),
    4: .same(proto: "isEquipped"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._itemID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._typeID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.quantity) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isEquipped) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._itemID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._typeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.quantity != 0 {
      try visitor.visitSingularUInt64Field(value: self.quantity, fieldNumber: 3)
    }
    if self.isEquipped != false {
      try visitor.visitSingularBoolField(value: self.isEquipped, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Item, rhs: RABackend_Item) -> Bool {
    if lhs._itemID != rhs._itemID {return false}
    if lhs._typeID != rhs._typeID {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.isEquipped != rhs.isEquipped {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_ItemSpecifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ItemSpecifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemType"),
    2: .same(proto: "quantity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.itemType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.quantity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.itemType.isEmpty {
      try visitor.visitSingularStringField(value: self.itemType, fieldNumber: 1)
    }
    if self.quantity != 0 {
      try visitor.visitSingularUInt64Field(value: self.quantity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_ItemSpecifier, rhs: RABackend_ItemSpecifier) -> Bool {
    if lhs.itemType != rhs.itemType {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_DroppedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DroppedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "droppedItemID"),
    2: .same(proto: "item"),
    3: .same(proto: "position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._droppedItemID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._item) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._droppedItemID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._item {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_DroppedItem, rhs: RABackend_DroppedItem) -> Bool {
    if lhs._droppedItemID != rhs._droppedItemID {return false}
    if lhs._item != rhs._item {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_MountingPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MountingPoints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characterID"),
    2: .same(proto: "mountingPoints"),
    3: .same(proto: "capacities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characterID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.mountingPoints) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.capacities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characterID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.mountingPoints.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.mountingPoints, fieldNumber: 2)
    }
    if !self.capacities.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.capacities, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_MountingPoints, rhs: RABackend_MountingPoints) -> Bool {
    if lhs._characterID != rhs._characterID {return false}
    if lhs.mountingPoints != rhs.mountingPoints {return false}
    if lhs.capacities != rhs.capacities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_AddWaypointParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddWaypointParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "position"),
    3: .same(proto: "at"),
    4: .same(proto: "for"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.at) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.`for`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.at != 0 {
      try visitor.visitSingularUInt64Field(value: self.at, fieldNumber: 3)
    }
    if self.`for` != 0 {
      try visitor.visitSingularUInt64Field(value: self.`for`, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_AddWaypointParams, rhs: RABackend_AddWaypointParams) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs.at != rhs.at {return false}
    if lhs.`for` != rhs.`for` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_GameStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tick"),
    2: .same(proto: "Venue"),
    3: .same(proto: "activeCharacter"),
    4: .same(proto: "hasCharactersPresentList"),
    5: .same(proto: "charactersPresentList"),
    6: .same(proto: "hasFacilityList"),
    7: .same(proto: "facilities"),
    8: .same(proto: "hasDroppedItemsList"),
    9: .same(proto: "droppedItems"),
    10: .same(proto: "hasOperation"),
    11: .same(proto: "timeRemaining"),
    12: .same(proto: "result"),
  ]

  fileprivate class _StorageClass {
    var _tick: UInt64 = 0
    var _Venue: RABackend_Venue? = nil
    var _activeCharacter: RABackend_ActiveCharacter? = nil
    var _hasCharactersPresentList_p: Bool = false
    var _charactersPresentList: [RABackend_Character] = []
    var _hasFacilityList_p: Bool = false
    var _facilities: [RABackend_Facility] = []
    var _hasDroppedItemsList_p: Bool = false
    var _droppedItems: [RABackend_DroppedItem] = []
    var _hasOperation_p: Bool = false
    var _timeRemaining: UInt64 = 0
    var _result: RABackend_OperationResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tick = source._tick
      _Venue = source._Venue
      _activeCharacter = source._activeCharacter
      _hasCharactersPresentList_p = source._hasCharactersPresentList_p
      _charactersPresentList = source._charactersPresentList
      _hasFacilityList_p = source._hasFacilityList_p
      _facilities = source._facilities
      _hasDroppedItemsList_p = source._hasDroppedItemsList_p
      _droppedItems = source._droppedItems
      _hasOperation_p = source._hasOperation_p
      _timeRemaining = source._timeRemaining
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._tick) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._Venue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._activeCharacter) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._hasCharactersPresentList_p) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._charactersPresentList) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._hasFacilityList_p) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._facilities) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._hasDroppedItemsList_p) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._droppedItems) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._hasOperation_p) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeRemaining) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._tick != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._tick, fieldNumber: 1)
      }
      try { if let v = _storage._Venue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._activeCharacter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._hasCharactersPresentList_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasCharactersPresentList_p, fieldNumber: 4)
      }
      if !_storage._charactersPresentList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._charactersPresentList, fieldNumber: 5)
      }
      if _storage._hasFacilityList_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasFacilityList_p, fieldNumber: 6)
      }
      if !_storage._facilities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._facilities, fieldNumber: 7)
      }
      if _storage._hasDroppedItemsList_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasDroppedItemsList_p, fieldNumber: 8)
      }
      if !_storage._droppedItems.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._droppedItems, fieldNumber: 9)
      }
      if _storage._hasOperation_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasOperation_p, fieldNumber: 10)
      }
      if _storage._timeRemaining != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timeRemaining, fieldNumber: 11)
      }
      try { if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_GameStatus, rhs: RABackend_GameStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tick != rhs_storage._tick {return false}
        if _storage._Venue != rhs_storage._Venue {return false}
        if _storage._activeCharacter != rhs_storage._activeCharacter {return false}
        if _storage._hasCharactersPresentList_p != rhs_storage._hasCharactersPresentList_p {return false}
        if _storage._charactersPresentList != rhs_storage._charactersPresentList {return false}
        if _storage._hasFacilityList_p != rhs_storage._hasFacilityList_p {return false}
        if _storage._facilities != rhs_storage._facilities {return false}
        if _storage._hasDroppedItemsList_p != rhs_storage._hasDroppedItemsList_p {return false}
        if _storage._droppedItems != rhs_storage._droppedItems {return false}
        if _storage._hasOperation_p != rhs_storage._hasOperation_p {return false}
        if _storage._timeRemaining != rhs_storage._timeRemaining {return false}
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_OperationSpecifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationSpecifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "facility"),
    2: .same(proto: "operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._facility) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._facility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_OperationSpecifier, rhs: RABackend_OperationSpecifier) -> Bool {
    if lhs._facility != rhs._facility {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_InteractionSpecifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InteractionSpecifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "facility"),
    2: .same(proto: "operation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._facility) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._facility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_InteractionSpecifier, rhs: RABackend_InteractionSpecifier) -> Bool {
    if lhs._facility != rhs._facility {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_OperationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeRemaining"),
    2: .same(proto: "isAnticipatory"),
    3: .same(proto: "willContinue"),
    4: .same(proto: "awardedItems"),
    5: .same(proto: "awardedXP"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timeRemaining) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isAnticipatory) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.willContinue) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.awardedItems) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.awardedXp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeRemaining != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeRemaining, fieldNumber: 1)
    }
    if self.isAnticipatory != false {
      try visitor.visitSingularBoolField(value: self.isAnticipatory, fieldNumber: 2)
    }
    if self.willContinue != false {
      try visitor.visitSingularBoolField(value: self.willContinue, fieldNumber: 3)
    }
    if !self.awardedItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.awardedItems, fieldNumber: 4)
    }
    if !self.awardedXp.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.awardedXp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_OperationStatus, rhs: RABackend_OperationStatus) -> Bool {
    if lhs.timeRemaining != rhs.timeRemaining {return false}
    if lhs.isAnticipatory != rhs.isAnticipatory {return false}
    if lhs.willContinue != rhs.willContinue {return false}
    if lhs.awardedItems != rhs.awardedItems {return false}
    if lhs.awardedXp != rhs.awardedXp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_XP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".XP"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "skill"),
    2: .same(proto: "xp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.skill) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.xp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.skill.isEmpty {
      try visitor.visitSingularStringField(value: self.skill, fieldNumber: 1)
    }
    if self.xp != 0 {
      try visitor.visitSingularInt64Field(value: self.xp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_XP, rhs: RABackend_XP) -> Bool {
    if lhs.skill != rhs.skill {return false}
    if lhs.xp != rhs.xp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_OperationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newItems"),
    2: .same(proto: "consumedItems"),
    3: .same(proto: "skill"),
    4: .same(proto: "xpEarned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.newItems) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.consumedItems) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.skill) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.xpEarned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newItems, fieldNumber: 1)
    }
    if !self.consumedItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.consumedItems, fieldNumber: 2)
    }
    if self.skill != .speed {
      try visitor.visitSingularEnumField(value: self.skill, fieldNumber: 3)
    }
    if self.xpEarned != 0 {
      try visitor.visitSingularUInt64Field(value: self.xpEarned, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_OperationResult, rhs: RABackend_OperationResult) -> Bool {
    if lhs.newItems != rhs.newItems {return false}
    if lhs.consumedItems != rhs.consumedItems {return false}
    if lhs.skill != rhs.skill {return false}
    if lhs.xpEarned != rhs.xpEarned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Venue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Venue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "region"),
    5: .same(proto: "orientation"),
    6: .same(proto: "bounds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.region) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.orientation) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._bounds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularBytesField(value: self.region, fieldNumber: 4)
    }
    if self.orientation != .point {
      try visitor.visitSingularEnumField(value: self.orientation, fieldNumber: 5)
    }
    try { if let v = self._bounds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Venue, rhs: RABackend_Venue) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.region != rhs.region {return false}
    if lhs.orientation != rhs.orientation {return false}
    if lhs._bounds != rhs._bounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_DroppedItemList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DroppedItemList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_DroppedItemList, rhs: RABackend_DroppedItemList) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Facility: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Facility"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "kind"),
    3: .same(proto: "position"),
    4: .same(proto: "interactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.interactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 2)
    }
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.interactions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.interactions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Facility, rhs: RABackend_Facility) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._position != rhs._position {return false}
    if lhs.interactions != rhs.interactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_FacilityList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FacilityList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "facilities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.facilities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.facilities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.facilities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_FacilityList, rhs: RABackend_FacilityList) -> Bool {
    if lhs.facilities != rhs.facilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Region: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Region"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.region) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularBytesField(value: self.region, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Region, rhs: RABackend_Region) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Size"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularDoubleField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Size, rhs: RABackend_Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Endorsement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Endorsement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "buff"),
    3: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._buff) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .plain {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._buff {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.params.isEmpty {
      try visitor.visitSingularStringField(value: self.params, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Endorsement, rhs: RABackend_Endorsement) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._buff != rhs._buff {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Character: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Character"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characterID"),
    2: .same(proto: "displayName"),
    4: .same(proto: "venue"),
    5: .same(proto: "locality"),
    6: .same(proto: "facing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._characterID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._venue) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._locality) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.facing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._characterID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    try { if let v = self._venue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._locality {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.facing != 0 {
      try visitor.visitSingularUInt64Field(value: self.facing, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Character, rhs: RABackend_Character) -> Bool {
    if lhs._characterID != rhs._characterID {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._venue != rhs._venue {return false}
    if lhs._locality != rhs._locality {return false}
    if lhs.facing != rhs.facing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_ActiveCharacter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveCharacter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "Character"),
    6: .same(proto: "attributes"),
    7: .same(proto: "items"),
    8: .same(proto: "mountingPoints"),
    9: .same(proto: "memes"),
    10: .same(proto: "buffs"),
    11: .same(proto: "attributeTimesRemaining"),
    12: .same(proto: "skillTimesRemaining"),
    13: .same(proto: "endorsements"),
    14: .same(proto: "operation"),
    15: .same(proto: "occupied"),
  ]

  fileprivate class _StorageClass {
    var _id: RABackend_CharacterID? = nil
    var _Character: RABackend_Character? = nil
    var _attributes: Dictionary<String,Int64> = [:]
    var _items: [RABackend_Item] = []
    var _mountingPoints: RABackend_MountingPoints? = nil
    var _memes: Data = Data()
    var _buffs: Data = Data()
    var _attributeTimesRemaining: Dictionary<String,UInt64> = [:]
    var _skillTimesRemaining: Dictionary<String,UInt64> = [:]
    var _endorsements: Dictionary<String,RABackend_Endorsement> = [:]
    var _operation: RABackend_OperationStatus? = nil
    var _occupied: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _Character = source._Character
      _attributes = source._attributes
      _items = source._items
      _mountingPoints = source._mountingPoints
      _memes = source._memes
      _buffs = source._buffs
      _attributeTimesRemaining = source._attributeTimesRemaining
      _skillTimesRemaining = source._skillTimesRemaining
      _endorsements = source._endorsements
      _operation = source._operation
      _occupied = source._occupied
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._Character) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._attributes) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._items) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._mountingPoints) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._memes) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._buffs) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &_storage._attributeTimesRemaining) }()
        case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &_storage._skillTimesRemaining) }()
        case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,RABackend_Endorsement>.self, value: &_storage._endorsements) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._operation) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._occupied) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._Character {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._attributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._attributes, fieldNumber: 6)
      }
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 7)
      }
      try { if let v = _storage._mountingPoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._memes.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._memes, fieldNumber: 9)
      }
      if !_storage._buffs.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._buffs, fieldNumber: 10)
      }
      if !_storage._attributeTimesRemaining.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: _storage._attributeTimesRemaining, fieldNumber: 11)
      }
      if !_storage._skillTimesRemaining.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: _storage._skillTimesRemaining, fieldNumber: 12)
      }
      if !_storage._endorsements.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,RABackend_Endorsement>.self, value: _storage._endorsements, fieldNumber: 13)
      }
      try { if let v = _storage._operation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._occupied != false {
        try visitor.visitSingularBoolField(value: _storage._occupied, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_ActiveCharacter, rhs: RABackend_ActiveCharacter) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._Character != rhs_storage._Character {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._items != rhs_storage._items {return false}
        if _storage._mountingPoints != rhs_storage._mountingPoints {return false}
        if _storage._memes != rhs_storage._memes {return false}
        if _storage._buffs != rhs_storage._buffs {return false}
        if _storage._attributeTimesRemaining != rhs_storage._attributeTimesRemaining {return false}
        if _storage._skillTimesRemaining != rhs_storage._skillTimesRemaining {return false}
        if _storage._endorsements != rhs_storage._endorsements {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._occupied != rhs_storage._occupied {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Credentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Credentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "player"),
    2: .same(proto: "passkey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._player) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.passkey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._player {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.passkey.isEmpty {
      try visitor.visitSingularStringField(value: self.passkey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Credentials, rhs: RABackend_Credentials) -> Bool {
    if lhs._player != rhs._player {return false}
    if lhs.passkey != rhs.passkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_AuthenticationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authenticated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.authenticated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.authenticated != false {
      try visitor.visitSingularBoolField(value: self.authenticated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_AuthenticationResponse, rhs: RABackend_AuthenticationResponse) -> Bool {
    if lhs.authenticated != rhs.authenticated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_NewPlayerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewPlayerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "familyName"),
    2: .same(proto: "playerID"),
    3: .same(proto: "passwordHash"),
    4: .same(proto: "salt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._playerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.passwordHash) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 1)
    }
    try { if let v = self._playerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.passwordHash.isEmpty {
      try visitor.visitSingularStringField(value: self.passwordHash, fieldNumber: 3)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_NewPlayerRequest, rhs: RABackend_NewPlayerRequest) -> Bool {
    if lhs.familyName != rhs.familyName {return false}
    if lhs._playerID != rhs._playerID {return false}
    if lhs.passwordHash != rhs.passwordHash {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_NewPlayerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewPlayerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playerID"),
    2: .same(proto: "empty"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RABackend_PlayerID?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .playerID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .playerID(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .empty(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .playerID?: try {
      guard case .playerID(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .empty?: try {
      guard case .empty(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_NewPlayerResponse, rhs: RABackend_NewPlayerResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_SaltResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SaltResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "salt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_SaltResponse, rhs: RABackend_SaltResponse) -> Bool {
    if lhs.salt != rhs.salt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playerID"),
    2: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._playerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_LoginRequest, rhs: RABackend_LoginRequest) -> Bool {
    if lhs._playerID != rhs._playerID {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "empty"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.responses {
          hadOneofValue = true
          if case .empty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responses = .empty(v)
        }
      }()
      case 2: try {
        var v: RABackend_LoginInfo?
        var hadOneofValue = false
        if let current = self.responses {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responses = .info(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responses {
    case .empty?: try {
      guard case .empty(let v)? = self.responses else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .info?: try {
      guard case .info(let v)? = self.responses else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_LoginResponse, rhs: RABackend_LoginResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_LoginInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activeCharacter"),
    2: .same(proto: "passkey"),
    3: .same(proto: "id"),
    4: .same(proto: "gameplayPortalEndpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activeCharacter) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.passkey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._gameplayPortalEndpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activeCharacter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.passkey.isEmpty {
      try visitor.visitSingularStringField(value: self.passkey, fieldNumber: 2)
    }
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gameplayPortalEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_LoginInfo, rhs: RABackend_LoginInfo) -> Bool {
    if lhs._activeCharacter != rhs._activeCharacter {return false}
    if lhs.passkey != rhs.passkey {return false}
    if lhs._id != rhs._id {return false}
    if lhs._gameplayPortalEndpoint != rhs._gameplayPortalEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_VenueID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VenueID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_VenueID, rhs: RABackend_VenueID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_PlayerID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayerID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_PlayerID, rhs: RABackend_PlayerID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_ItemTypeID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ItemTypeID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_ItemTypeID, rhs: RABackend_ItemTypeID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_ItemID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ItemID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_ItemID, rhs: RABackend_ItemID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_DroppedItemID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DroppedItemID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_DroppedItemID, rhs: RABackend_DroppedItemID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_FacilityID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FacilityID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_FacilityID, rhs: RABackend_FacilityID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_CharacterID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterID"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_CharacterID, rhs: RABackend_CharacterID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_CharacterIDList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacterIDList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ActiveCharacter"),
    2: .same(proto: "characters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activeCharacter) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.characters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activeCharacter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.characters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_CharacterIDList, rhs: RABackend_CharacterIDList) -> Bool {
    if lhs._activeCharacter != rhs._activeCharacter {return false}
    if lhs.characters != rhs.characters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RABackend_Endpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Endpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "port"),
    3: .same(proto: "test"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.test) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.port.isEmpty {
      try visitor.visitSingularStringField(value: self.port, fieldNumber: 2)
    }
    if !self.test.isEmpty {
      try visitor.visitSingularStringField(value: self.test, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RABackend_Endpoint, rhs: RABackend_Endpoint) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.test != rhs.test {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
